# План реализации Telegram-бота FindOrigin

## Этап 1: Настройка проекта и окружения

1.1. Инициализация Next.js проекта
- Создать Next.js приложение с TypeScript
- Настроить структуру папок (app router или pages router)
- Установить необходимые зависимости

1.2. Настройка переменных окружения
- Создать `.env.local` файл
- Добавить переменные:
  - `TELEGRAM_BOT_TOKEN` - токен бота от BotFather
  - `TELEGRAM_API_URL` - базовый URL Telegram API
  - `WEBHOOK_SECRET` (опционально) - для безопасности webhook
  - API ключи для AI сервиса (если требуется)

1.3. Настройка конфигурации проекта
- Настроить `next.config.js` для работы с API routes
- Подготовить структуру для деплоя на Vercel

## Этап 2: Создание Telegram бота и настройка webhook

2.1. Регистрация бота в Telegram
- Создать бота через @BotFather
- Получить токен бота
- Настроить базовую информацию о боте

2.2. Реализация webhook endpoint
- Создать API route в Next.js (`/api/webhook` или `/api/telegram`)
- Реализовать POST обработчик для получения updates от Telegram
- Добавить валидацию входящих запросов
- Реализовать быстрый ответ 200 OK (асинхронная обработка)

2.3. Настройка webhook в Telegram
- Создать функцию для установки webhook через Telegram API
- Настроить webhook URL для продакшена (Vercel)

## Этап 3: Обработка входящих сообщений

3.1. Парсинг update от Telegram
- Извлечение `chat.id` из `update.message`
- Извлечение `text` из `update.message`
- Обработка различных типов сообщений (текст, ссылки)

3.2. Определение типа ввода
- Проверка, является ли сообщение текстом или ссылкой
- Валидация формата ссылки на Telegram-пост

3.3. Обработка ошибок
- Обработка некорректных форматов
- Обработка отсутствующих данных
- Логирование ошибок

## Этап 4: Извлечение текста из Telegram-постов

4.1. Парсинг ссылок на Telegram-посты
- Определение формата ссылки (t.me/channel/message_id)
- Извлечение channel и message_id из URL

4.2. Получение контента поста через Telegram API
- Использование метода `getUpdates` или `forwardMessage` (если доступно)
- Альтернатива: парсинг через Telegram Web (если возможно)
- Обработка случаев недоступности поста

4.3. Извлечение текста из поста
- Получение текстового содержимого
- Обработка форматирования (Markdown, HTML)
- Очистка текста от лишних символов

## Этап 5: Анализ текста и извлечение ключевой информации

5.1. Выделение ключевых утверждений
- Использование NLP библиотек или AI для определения основных тезисов
- Извлечение фактологических утверждений

5.2. Извлечение структурированных данных
- Даты (распознавание различных форматов)
- Числа и статистика
- Имена собственные (люди, организации, места)
- Ссылки (если присутствуют в тексте)

5.3. Подготовка поисковых запросов
- Формирование поисковых запросов на основе извлеченной информации
- Оптимизация запросов для поиска источников

## Этап 6: Поиск возможных источников

6.1. Интеграция с поисковыми системами
- Выбор поискового API (Google Search API, Bing Search API, или альтернативы)
- Настройка API ключей
- Реализация функции поиска

6.2. Фильтрация результатов по типам источников
- Официальные сайты (определение по доменам .gov, .edu, официальные организации)
- Новостные сайты (известные новостные агентства)
- Блоги и экспертные ресурсы
- Исследования и научные публикации

6.3. Сборка списка кандидатов
- Получение топ-10-20 результатов поиска
- Извлечение URL, заголовков, сниппетов
- Подготовка данных для AI-сравнения

## Этап 7: AI-сравнение и оценка релевантности

7.1. Интеграция с AI сервисом
- Выбор AI сервиса (OpenAI GPT, Anthropic Claude, или локальное решение)
- Настройка API для сравнения текстов

7.2. Реализация семантического сравнения
- Сравнение смысла исходного текста с найденными источниками
- Использование embeddings для семантического поиска
- Оценка релевантности каждого источника

7.3. Ранжирование и фильтрация
- Сортировка источников по релевантности
- Выбор топ-3 наиболее релевантных источников
- Расчет оценки уверенности (confidence score)

## Этап 8: Форматирование и отправка ответа

8.1. Форматирование результатов
- Создание структурированного ответа с:
  - Списком источников (1-3 ссылки)
  - Оценкой уверенности для каждого
  - Кратким описанием релевантности

8.2. Отправка сообщения через Telegram API
- Использование метода `sendMessage`
- Форматирование текста (Markdown или HTML)
- Обработка длинных сообщений (разбивка на части)

8.3. Обработка ошибок отправки
- Retry логика при ошибках API
- Уведомление пользователя об ошибках
- Логирование проблем

## Этап 9: Оптимизация и асинхронная обработка

9.1. Реализация асинхронной обработки
- Использование очередей (например, Vercel Queue или внешний сервис)
- Быстрый ответ webhook (200 OK)
- Фоновая обработка запроса

9.2. Кэширование результатов
- Кэширование результатов поиска для похожих запросов
- Использование Redis или Vercel KV (если доступно)

9.3. Оптимизация производительности
- Оптимизация запросов к внешним API
- Параллельная обработка где возможно
- Ограничение времени выполнения

## Этап 10: Тестирование

10.1. Модульное тестирование
- Тесты для парсинга сообщений
- Тесты для извлечения текста
- Тесты для анализа текста

10.2. Интеграционное тестирование
- Тесты webhook endpoint
- Тесты интеграции с Telegram API
- Тесты поиска источников

10.3. E2E тестирование
- Тестирование полного потока от сообщения до ответа
- Тестирование различных типов ввода
- Тестирование обработки ошибок

## Этап 11: Деплой и мониторинг

11.1. Подготовка к деплою на Vercel
- Настройка `vercel.json` (если требуется)
- Настройка переменных окружения в Vercel
- Настройка домена (если требуется)

11.2. Деплой приложения
- Подключение репозитория к Vercel
- Настройка автоматического деплоя
- Проверка работоспособности после деплоя

11.3. Настройка webhook в продакшене
- Установка webhook URL на продакшен домен
- Проверка получения updates

11.4. Мониторинг и логирование
- Настройка логирования (Vercel Logs или внешний сервис)
- Мониторинг ошибок
- Отслеживание использования API

## Этап 12: Документация и финализация

12.1. Документация кода
- Комментарии в коде
- README с инструкциями по установке и запуску

12.2. Пользовательская документация
- Описание функционала бота
- Примеры использования
- FAQ

12.3. Финальная проверка
- Проверка всех функций
- Исправление найденных багов
- Оптимизация производительности

