# План реализации Telegram-бота FindOrigin

## Этап 1: Настройка проекта и окружения

1.1. Инициализация Next.js проекта
1. Создать Next.js приложение с TypeScript
2. Настроить структуру папок (app router или pages router)
3. Установить необходимые зависимости

1.2. Настройка переменных окружения
1. Создать `.env.local` файл
2. Добавить переменные:
   1. `TELEGRAM_BOT_TOKEN` - токен бота от BotFather
   2. `TELEGRAM_API_URL` - базовый URL Telegram API
   3. `WEBHOOK_SECRET` (опционально) - для безопасности webhook
   4. API ключи для AI сервиса (если требуется)

1.3. Настройка конфигурации проекта
1. Настроить `next.config.js` для работы с API routes
2. Подготовить структуру для деплоя на Vercel

## Этап 2: Создание Telegram бота и настройка webhook

2.1. Регистрация бота в Telegram
1. Создать бота через @BotFather
2. Получить токен бота
3. Настроить базовую информацию о боте

2.2. Реализация webhook endpoint
1. Создать API route в Next.js (`/api/webhook` или `/api/telegram`)
2. Реализовать POST обработчик для получения updates от Telegram
3. Добавить валидацию входящих запросов
4. Реализовать быстрый ответ 200 OK (асинхронная обработка)

2.3. Настройка webhook в Telegram
1. Создать функцию для установки webhook через Telegram API
2. Настроить webhook URL для продакшена (Vercel)

## Этап 3: Обработка входящих сообщений

3.1. Парсинг update от Telegram
1. Извлечение `chat.id` из `update.message`
2. Извлечение `text` из `update.message`
3. Обработка различных типов сообщений (текст, ссылки)

3.2. Определение типа ввода
1. Проверка, является ли сообщение текстом или ссылкой
2. Валидация формата ссылки на Telegram-пост

3.3. Обработка ошибок
1. Обработка некорректных форматов
2. Обработка отсутствующих данных
3. Логирование ошибок

## Этап 4: Извлечение текста из Telegram-постов

4.1. Парсинг ссылок на Telegram-посты
1. Определение формата ссылки (t.me/channel/message_id)
2. Извлечение channel и message_id из URL

4.2. Получение контента поста через Telegram API
1. Использование метода `getUpdates` или `forwardMessage` (если доступно)
2. Альтернатива: парсинг через Telegram Web (если возможно)
3. Обработка случаев недоступности поста

4.3. Извлечение текста из поста
1. Получение текстового содержимого
2. Обработка форматирования (Markdown, HTML)
3. Очистка текста от лишних символов

## Этап 5: Анализ текста и извлечение ключевой информации

5.1. Выделение ключевых утверждений
1. Использование NLP библиотек или AI для определения основных тезисов
2. Извлечение фактологических утверждений

5.2. Извлечение структурированных данных
1. Даты (распознавание различных форматов)
2. Числа и статистика
3. Имена собственные (люди, организации, места)
4. Ссылки (если присутствуют в тексте)

5.3. Подготовка поисковых запросов
1. Формирование поисковых запросов на основе извлеченной информации
2. Оптимизация запросов для поиска источников

## Этап 6: Поиск возможных источников

6.1. Получение доступа к поисковым API

6.1.1. Google Custom Search API
1. ✅ Регистрация/вход в Google Cloud Console (https://console.cloud.google.com)
2. ✅ Создание нового проекта или выбор существующего (проект "findorigin")
3. ✅ Включение Custom Search API в проекте:
   1. ✅ Переход в "APIs & Services" → "Library"
   2. ✅ Поиск "Custom Search API"
   3. ✅ Нажатие "Enable" для активации API
4. Создание API ключа:
   1. Переход в "APIs & Services" → "Credentials"
   2. Нажатие "Create Credentials" → "API Key"
   3. Ограничение ключа (рекомендуется):
      1. Выбор "Restrict key"
      2. В разделе "API restrictions" выбрать "Custom Search API"
      3. Сохранение ключа
5. Создание поисковой машины (Custom Search Engine):
   1. Переход на https://cse.google.com/cse/all
   2. Нажатие "Add" для создания новой поисковой системы
   3. Настройка поисковой системы:
      1. Ввод названия и описания
      2. Выбор языка
      3. Настройка области поиска (весь интернет или конкретные сайты)
   4. Получение Search Engine ID (cx) из настроек созданной системы
6. Сохранение ключей:
   1. `GOOGLE_API_KEY` - API ключ из Google Cloud Console
   2. `GOOGLE_SEARCH_ENGINE_ID` - Search Engine ID из cse.google.com

6.1.2. Bing Search API (альтернатива Google)
1. Регистрация/вход в Azure Portal (https://portal.azure.com)
2. Создание ресурса Bing Search:
   1. Поиск "Bing Search v7" в Azure Marketplace
   2. Нажатие "Create"
   3. Заполнение формы:
      1. Выбор подписки (или создание бесплатной)
      2. Создание или выбор Resource Group
      3. Ввод названия ресурса
      4. Выбор Pricing tier (Free F1 для бесплатного тарифа)
   4. Нажатие "Review + create" → "Create"
3. Получение API ключа:
   1. Переход в созданный ресурс
   2. Выбор "Keys and Endpoint" в меню
   3. Копирование "Key 1"
4. Сохранение ключа:
   1. `BING_API_KEY` - API ключ из Azure Portal

6.1.3. SerpAPI (альтернативный вариант)
1. Регистрация на https://serpapi.com
2. Создание аккаунта (бесплатный тариф: 100 запросов/месяц)
3. Получение API ключа:
   1. Переход в Dashboard
   2. Копирование API ключа из раздела "API Key"
4. Сохранение ключа:
   1. `SERPAPI_KEY` - API ключ из SerpAPI Dashboard

6.2. Настройка переменных окружения
1. Добавление ключей в `.env.local` для локальной разработки:
   1. `GOOGLE_API_KEY=your_google_api_key`
   2. `GOOGLE_SEARCH_ENGINE_ID=your_search_engine_id`
   3. `BING_API_KEY=your_bing_api_key` (опционально)
   4. `SERPAPI_KEY=your_serpapi_key` (опционально)
2. Добавление ключей в Vercel для продакшена:
   1. Переход в Settings → Environment Variables
   2. Добавление всех необходимых переменных
   3. Передеплой проекта после добавления

6.3. Интеграция с поисковыми системами
1. Реализация функции поиска для каждого API:
   1. Создание модулей в `lib/search-apis/`:
      1. `google-search.ts` - для Google Custom Search API
      2. `bing-search.ts` - для Bing Search API
      3. `serpapi-search.ts` - для SerpAPI
   2. Реализация унифицированного интерфейса для всех API
   3. Обработка ошибок и таймаутов
2. Реализация приоритизации API:
   1. Попытка использования Google Search API (приоритет 1)
   2. Fallback на Bing Search API (приоритет 2)
   3. Fallback на SerpAPI (приоритет 3)

6.4. Фильтрация результатов по типам источников
1. Официальные сайты (определение по доменам .gov, .edu, официальные организации)
2. Новостные сайты (известные новостные агентства)
3. Блоги и экспертные ресурсы
4. Исследования и научные публикации

6.5. Сборка списка кандидатов
1. Получение топ-10-20 результатов поиска
2. Извлечение URL, заголовков, сниппетов
3. Определение типа источника для каждого результата
4. Подготовка данных для AI-сравнения

## Этап 7: AI-сравнение и оценка релевантности

7.1. Получение доступа к AI сервисам

7.1.1. OpenAI API (рекомендуемый вариант)
1. Регистрация/вход на https://platform.openai.com
2. Создание аккаунта или вход в существующий
3. Получение API ключа:
   1. Переход в "API keys" (https://platform.openai.com/api-keys)
   2. Нажатие "Create new secret key"
   3. Ввод названия ключа (например: "FindOrigin Bot")
   4. Копирование ключа (начинается с `sk-...`)
   5. **Важно:** Сохранить ключ сразу, он больше не будет показан
4. Проверка баланса и лимитов:
   1. Переход в "Usage" для проверки доступных кредитов
   2. Бесплатный тариф: $5 кредитов при регистрации
   3. Платный тариф: пополнение баланса по необходимости
5. Выбор модели:
   1. Рекомендуемая: `gpt-4o-mini` (баланс качества и стоимости)
   2. Альтернативы: `gpt-4o`, `gpt-3.5-turbo`
6. Сохранение ключа:
   1. `OPENAI_API_KEY` - API ключ из OpenAI Platform

7.1.2. Anthropic Claude API (альтернатива)
1. Регистрация на https://console.anthropic.com
2. Создание аккаунта или вход в существующий
3. Получение API ключа:
   1. Переход в "API Keys"
   2. Нажатие "Create Key"
   3. Ввод названия и описание
   4. Копирование ключа (начинается с `sk-ant-...`)
4. Проверка лимитов:
   1. Бесплатный тариф: ограниченное количество запросов
   2. Платный тариф: оплата по использованию
5. Сохранение ключа:
   1. `ANTHROPIC_API_KEY` - API ключ из Anthropic Console

7.1.3. Локальное решение (опционально)
1. Установка локальной модели (например, через Ollama)
2. Настройка локального API endpoint
3. Использование для разработки/тестирования

7.2. Настройка переменных окружения
1. Добавление ключей в `.env.local` для локальной разработки:
   1. `OPENAI_API_KEY=your_openai_key` (обязательно для продакшена)
   2. `ANTHROPIC_API_KEY=your_anthropic_key` (опционально)
2. Добавление ключей в Vercel для продакшена:
   1. Переход в Settings → Environment Variables
   2. Добавление `OPENAI_API_KEY`
   3. Передеплой проекта после добавления

7.3. Интеграция с AI сервисом
1. Реализация модуля для работы с AI:
   1. Создание `lib/ai-comparison.ts`
   2. Реализация функции `compareWithAI()`:
      1. Формирование промпта для сравнения
      2. Отправка запроса к OpenAI API
      3. Парсинг ответа от AI
      4. Обработка ошибок и fallback
2. Настройка параметров запроса:
   1. Выбор модели (`gpt-4o-mini`)
   2. Настройка температуры (0.3 для детерминированных результатов)
   3. Формат ответа (JSON)
   4. Обработка таймаутов

7.4. Реализация семантического сравнения
1. Формирование промпта для AI:
   1. Исходный текст пользователя
   2. Список найденных источников (URL, заголовок, сниппет)
   3. Инструкции для оценки релевантности
2. Отправка запроса к AI:
   1. Использование Chat Completions API
   2. Формирование системного промпта
   3. Формирование пользовательского промпта с данными
3. Парсинг ответа AI:
   1. Извлечение оценки релевантности (0-100%)
   2. Извлечение уровня уверенности (high/medium/low)
   3. Извлечение объяснения на русском языке
4. Обработка ошибок:
   1. Fallback при недоступности AI
   2. Использование базовых оценок при ошибках

7.5. Ранжирование и фильтрация
1. Сортировка источников по релевантности (от большего к меньшему)
2. Фильтрация источников с низкой релевантностью (< 30%)
3. Выбор топ-3 наиболее релевантных источников
4. Расчет и отображение оценки уверенности (confidence score)
5. Формирование итогового списка с метаданными:
   1. Релевантность в процентах
   2. Уровень уверенности
   3. Краткое объяснение на русском

## Этап 8: Форматирование и отправка ответа

8.1. Форматирование результатов
1. Создание структурированного ответа с:
   1. Списком источников (1-3 ссылки)
   2. Оценкой уверенности для каждого
   3. Кратким описанием релевантности

8.2. Отправка сообщения через Telegram API
1. Использование метода `sendMessage`
2. Форматирование текста (Markdown или HTML)
3. Обработка длинных сообщений (разбивка на части)

8.3. Обработка ошибок отправки
1. Retry логика при ошибках API
2. Уведомление пользователя об ошибках
3. Логирование проблем

## Этап 9: Оптимизация и асинхронная обработка

9.1. Реализация асинхронной обработки
1. Использование очередей (например, Vercel Queue или внешний сервис)
2. Быстрый ответ webhook (200 OK)
3. Фоновая обработка запроса

9.2. Кэширование результатов
1. Кэширование результатов поиска для похожих запросов
2. Использование Redis или Vercel KV (если доступно)

9.3. Оптимизация производительности
1. Оптимизация запросов к внешним API
2. Параллельная обработка где возможно
3. Ограничение времени выполнения

## Этап 10: Тестирование

10.1. Модульное тестирование
1. Тесты для парсинга сообщений
2. Тесты для извлечения текста
3. Тесты для анализа текста

10.2. Интеграционное тестирование
1. Тесты webhook endpoint
2. Тесты интеграции с Telegram API
3. Тесты поиска источников

10.3. E2E тестирование
1. Тестирование полного потока от сообщения до ответа
2. Тестирование различных типов ввода
3. Тестирование обработки ошибок

## Этап 11: Деплой и мониторинг

11.1. Подготовка к деплою на Vercel
1. Настройка `vercel.json` (если требуется)
2. Настройка переменных окружения в Vercel
3. Настройка домена (если требуется)

11.2. Деплой приложения
1. Подключение репозитория к Vercel
2. Настройка автоматического деплоя
3. Проверка работоспособности после деплоя

11.3. Настройка webhook в продакшене
1. Установка webhook URL на продакшен домен
2. Проверка получения updates

11.4. Мониторинг и логирование
1. Настройка логирования (Vercel Logs или внешний сервис)
2. Мониторинг ошибок
3. Отслеживание использования API

## Этап 12: Документация и финализация

12.1. Документация кода
1. Комментарии в коде
2. README с инструкциями по установке и запуску

12.2. Пользовательская документация
1. Описание функционала бота
2. Примеры использования
3. FAQ

12.3. Финальная проверка
1. Проверка всех функций
2. Исправление найденных багов
3. Оптимизация производительности

